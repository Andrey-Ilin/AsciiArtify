# Demo and concept check

## Using AI for creating a collection of manifests for Kuberneter

| NAME | PROMPT | DESCRIPTOPN | EXAMPLE |
| ---- | --- | --- | --- |
| App | Please provide an app.yaml manifest with next requiements: apiVersion - v1; kind - Pod; name - app; labels - app=demo, run=demo; image - us-west2-docker.pkg.dev/annular-mesh-431721-j0/devops/gcr.io/k8s-k3s/demo:v1.0.0; port - 8080 and name http | YAML file creates a Pod named "app" running a single container based on an image hosted in a private Google Container Registry. The container listens on port 8080, and Kubernetes uses a secret to pull the image from the private registry. | [app.yaml](./yaml/app.yaml) |
| Configmap | Create a Kubernetes Pod YAML configuration with the following details: The Pod should be named app-config. It should contain one container named mypod using the redis image. The imagePullPolicy should be set to Always. Add an environment variable named CONFIGMAP_PARAM which should get its value from a ConfigMap named app-config, specifically from the key config-param. Mount a volume named config-volume to the container at the path /config. This volume should be populated with data from the app-config ConfigMap. Set the Podâ€™s restart policy to Never. | This Kubernetes manifest creates a Pod named app-config that runs a single container mypod using the redis image. The container has an environment variable CONFIGMAP_PARAM sourced from the config-param key in the app-config ConfigMap. The Pod also mounts a volume config-volume at /config inside the container, populated with data from the same ConfigMap. The imagePullPolicy is set to Always, and the restartPolicy is set to Never. | [app-configmap.yaml](./yaml/app-configmap.yaml) |
| Secret | Create a Kubernetes Pod named app-secret that runs a redis container. Mount a Secret named simple-secret as a read-only volume at /etc/foo inside the container. | This Kubernetes manifest defines a Pod named app-secret. The Pod runs a single container called mypod using the redis image. The container mounts a volume named foo at the path /etc/foo in read-only mode. This volume is populated with data from a Kubernetes Secret named simple-secret. The data in the Secret will be accessible as files in the /etc/foo directory inside the container. | [app-secret.yaml](./yaml/app-secret.yaml) |
| SecretEnv | Create a Kubernetes Pod named app-secret-env that runs a redis container. Set two environment variables, SECRET_USERNAME and SECRET_PASSWORD, using the username and password keys from a Secret named mysecret1. The Pod should not restart automatically. | This Kubernetes manifest defines a Pod named app-secret-env. The Pod runs a single container called mycontainer using the redis image. The container has two environment variables, SECRET_USERNAME and SECRET_PASSWORD, which get their values from a Kubernetes Secret named mysecret1. Specifically, SECRET_USERNAME is set using the username key, and SECRET_PASSWORD is set using the password key from the Secret. The Pod's restartPolicy is set to Never, meaning it will not restart automatically if the container exits. | [app-secret-env.yaml](./yaml/app-secret-env.yaml) |
| VolumeMounts | Create a Kubernetes Pod named app-volume that runs a container using the gcr.io/kuar-demo/kuard-amd64:1 image. Configure a liveness probe to check /healthy on port 8080, with an initial delay of 5 seconds, a timeout of 1 second, and a check every 10 seconds. The liveness probe should consider the container unhealthy after 3 consecutive failures. Also, configure a readiness probe to check /ready on port 8080, with an initial delay of 0 seconds, a check every 2 seconds, and consider the container ready after 1 successful check and not ready after 3 consecutive failures. Expose port 8080 and mount a hostPath volume from /var/lib/app on the host to /data in the container. | This Kubernetes manifest defines a Pod named app-volume that runs a single container named app using the image gcr.io/kuar-demo/kuard-amd64:1. The container is configured with a liveness probe that checks the container's health by sending an HTTP GET request to /healthy on port 8080, considering the container unhealthy and restarting it if it fails to respond successfully within 1 second after 3 consecutive failures, with checks occurring every 10 seconds starting 5 seconds after the container starts. Additionally, a readiness probe checks if the container is ready to serve traffic by sending an HTTP GET request to /ready on port 8080, marking the container as not ready if it fails 3 consecutive checks, which are performed every 2 seconds starting immediately after the container starts. The container also exposes port 8080 and mounts a hostPath volume at /data, mapping to the /var/lib/app directory on the host machine. | [app-volume-mounts.yaml](./yaml/app-volume-mounts.yaml) |
| CronJob | Create a Kubernetes CronJob named app-cronjob that runs a container using the bash image. The container should execute the command echo "Hello world" every 5 minutes. Set the job's restart policy to OnFailure so that the job is retried if it fails. | This Kubernetes manifest defines a CronJob named app-cronjob that schedules a job to run every 5 minutes. The job runs a single container named hello using the bash image, which executes the command echo "Hello world". The job is configured with a restart policy of OnFailure, ensuring it will be retried if it fails. | [app-cronjob.yaml](./yaml/app-cronjob.yaml) |
| AppJob | Create a Kubernetes Job named app-job-rsync that runs a container using the google/cloud-sdk:275.0.0-alpine image. The container should execute a command to synchronize files from a Google Cloud Storage bucket (gs://glow-sportradar/) to a GCE Persistent Disk (glow-data-disk-200) mounted at /data/input. The disk should use the ext4 filesystem. Set the Job's restart policy to Never and configure it to not retry if it fails (backoffLimit: 0). | This Kubernetes manifest defines a Job named app-job-rsync that runs a single container using the google/cloud-sdk:275.0.0-alpine image. The container executes a command to synchronize files from a Google Cloud Storage bucket (gs://glow-sportradar/) to a GCE Persistent Disk named glow-data-disk-200, mounted at /data/input. The disk uses the ext4 filesystem. The Job is configured not to restart automatically upon failure and will not retry if it fails, as specified by the restartPolicy: Never and backoffLimit: 0 settings. | [app-job.yaml](./yaml/app-job.yaml) |
| LivenessProbe | Create a Kubernetes Pod named app-livenessprob in the demo namespace. The Pod should run a container using an image from the Google Container Registry at us-west2-docker.pkg.dev/annular-mesh-431721-j0/devops/gcr.io/k8s-k3s/demo:v1.0.0. Configure a liveness probe to perform an HTTP GET request to / on port 8000, starting 5 seconds after the container starts, with a 1-second timeout, and checking every 10 seconds. The container should be restarted if the probe fails 3 consecutive times. Expose port 8080 from the container, and use an image pull secret named gcr-secret to access the private registry. | This Kubernetes manifest defines a Pod named app-livenessprob in the demo namespace, running a container from a private Google Container Registry. The Pod includes a liveness probe that checks the container's health by sending HTTP GET requests to / on port 8000, with a 5-second initial delay, 1-second timeout, and a check every 10 seconds. If the probe fails 3 consecutive times, the container will be restarted. The container exposes port 8080 and uses an image pull secret named gcr-secret for accessing the private registry. | [app-liveness-probe.yaml](./yaml/app-liveness-probe.yaml) |
| Multi Containers | Create a Kubernetes Pod named app-multi-containers that runs two containers. The first container should use the nginx image and mount a shared volume at /usr/share/nginx/html to serve static files. The second container should use the debian image, mount the same shared volume at /html, and run a shell command that continuously appends the current date and time to /html/index.html every second. The shared volume should be an emptyDir volume. | This Kubernetes manifest defines a Pod named app-multi-containers that runs two containers sharing an emptyDir volume named html. The first container uses the nginx image and serves content from /usr/share/nginx/html, while the second container uses the debian image and continuously appends the current date and time to an index.html file in the shared volume, mounted at /html. The two containers work together, with one generating content and the other serving it. | [app-multi-containers.yaml](./yaml/app-multi-containers.yaml) |
| RedinessProbe | Create a Kubernetes Pod named app-readinessprob that runs a container using an image from the Google Container Registry at us-west2-docker.pkg.dev/annular-mesh-431721-j0/devops/gcr.io/k8s-k3s/demo:v1.0.0. Configure a liveness probe to perform an HTTP GET request to / on port 8000, with an initial delay of 5 seconds, a 1-second timeout, and a check every 10 seconds, restarting the container after 3 consecutive failures. Also, configure a readiness probe to check the /ready path on port 8000, starting immediately, with a check every 2 seconds, marking the container as ready after 1 success and not ready after 3 consecutive failures. Expose port 8000 from the container. | This Kubernetes manifest defines a Pod named app-readinessprob, which runs a container from a private Google Container Registry. The Pod is configured with both a liveness probe and a readiness probe. The liveness probe checks the root path (/) of the container on port 8000 every 10 seconds, with a 5-second initial delay, and will restart the container if it fails 3 consecutive checks. The readiness probe checks the /ready path on port 8000 every 2 seconds, starting immediately, and marks the container as ready after 1 success and not ready after 3 consecutive failures. The container also exposes port 8000 for communication. | [app-rediness-probe.yaml](./yaml/app-readiness-probe.yaml) |
| Resources | Create a Kubernetes Pod named app-resource that runs a container using an image from Google Container Registry (gcr.io/kuar-demo/kuard-amd64:1). Configure a liveness probe to perform an HTTP GET request to /healthy on port 8080, with an initial delay of 5 seconds, a 1-second timeout, and a check every 10 seconds. Also, configure a readiness probe to check the /ready path on port 8080, starting immediately, with a check every 2 seconds, marking the container as ready after 1 success and not ready after 3 consecutive failures. Expose port 8080 from the container. Set resource requests of 100 milliCPU and 128 MiB memory, and resource limits of 100 milliCPU and 256 MiB memory. | This Kubernetes manifest defines a Pod named app-resource that runs a container from Google Container Registry. The container is configured with a liveness probe checking the /healthy path and a readiness probe checking the /ready path, both on port 8080. The container requests 100 milliCPU and 128 MiB of memory, with a limit of 100 milliCPU and 256 MiB of memory. The liveness and readiness probes ensure the container is healthy and ready to serve traffic, while the resource limits and requests manage the container's CPU and memory usage. | [app-resources.yaml](./yaml/app-resources.yaml) |

